# core/anti_malware.py
"""
Module anti-malware pour EduLocker
Détecte et neutralise le ransomware éducatif EduLocker
"""

import os
import sys
import platform
import subprocess
import logging
import threading

import psutil
import time
import tkinter as tk
from tkinter import messagebox, ttk

# Pour la gestion du registre Windows
if platform.system() == "Windows":
    try:
        import winreg
    except ImportError:
        logging.getLogger(__name__).error(
            "Module 'winreg' non trouvé. Les opérations de registre Windows échoueront."
            "Assurez-vous d'être sur Windows et que l'installation Python est correcte."
        )
        winreg = None  # Pour éviter des NameError plus tard


class EduLockerDetector:
    """Détecte la présence du ransomware éducatif EduLocker sur le système."""

    def __init__(self, logger=None):
        """
        Initialise le détecteur EduLocker.
        
        Args:
            logger: Logger pour enregistrer les actions (optionnel)
        """
        self.logger = logger or logging.getLogger('EduLockerDetector')
        self.detection_results = {}
        self.is_windows = platform.system() == "Windows"
        
        # Signatures connues d'EduLocker
        self.process_signatures = ["EduLocker", "python main.py --locked-startup"]
        self.registry_signatures = ["EduLockerUpdate", "EduLockerServicePOC"]
        self.scheduled_task_signatures = ["EduLockerUpdate", "EduLockerServicePOC"]
        
        self.logger.info("Détecteur EduLocker initialisé")

    def scan_system(self):
        """
        Effectue une analyse complète du système pour détecter EduLocker.
        
        Returns:
            dict: Résultats de détection avec les éléments trouvés
        """
        self.logger.info("Démarrage de l'analyse du système")
        self.detection_results = {
            "processes": self.scan_processes(),
            "registry": self.scan_registry() if self.is_windows else [],
            "scheduled_tasks": self.scan_scheduled_tasks() if self.is_windows else [],
            "files": self.scan_files(),
        }
        
        # Déterminer si EduLocker est présent
        is_detected = any([
            len(self.detection_results["processes"]) > 0,
            len(self.detection_results["registry"]) > 0,
            len(self.detection_results["scheduled_tasks"]) > 0,
            len(self.detection_results["files"]) > 0
        ])
        
        self.detection_results["detected"] = is_detected
        
        self.logger.info(f"Analyse terminée. EduLocker détecté: {is_detected}")
        return self.detection_results

    def scan_processes(self):
        """
        Recherche les processus liés à EduLocker.
        
        Returns:
            list: Liste des processus suspects trouvés
        """
        self.logger.info("Analyse des processus en cours...")
        suspicious_processes = []
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                # Vérifier le nom du processus et la ligne de commande
                proc_info = proc.info
                cmdline = " ".join(proc_info['cmdline']) if proc_info['cmdline'] else ""
                
                # Vérifier les signatures connues
                if any(sig.lower() in cmdline.lower() for sig in self.process_signatures):
                    suspicious_processes.append({
                        'pid': proc_info['pid'],
                        'name': proc_info['name'],
                        'cmdline': cmdline
                    })
                    self.logger.info(f"Processus suspect trouvé: PID {proc_info['pid']}, Commande: {cmdline}")
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        
        return suspicious_processes

    def scan_registry(self):
        """
        Recherche les entrées de registre liées à EduLocker (Windows uniquement).
        
        Returns:
            list: Liste des entrées de registre suspectes
        """
        if not self.is_windows or not winreg:
            return []
        
        self.logger.info("Analyse du registre Windows en cours...")
        suspicious_entries = []
        
        # Vérifier les clés de démarrage automatique
        try:
            key_path = r"Software\Microsoft\Windows\CurrentVersion\Run"
            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_READ) as key:
                i = 0
                while True:
                    try:
                        name, value, _ = winreg.EnumValue(key, i)
                        # Vérifier si le nom ou la valeur contient une signature connue
                        if any(sig.lower() in name.lower() for sig in self.registry_signatures) or \
                           any(sig.lower() in value.lower() for sig in self.registry_signatures):
                            suspicious_entries.append({
                                'location': f"HKCU\\{key_path}",
                                'name': name,
                                'value': value
                            })
                            self.logger.info(f"Entrée de registre suspecte trouvée: {name}")
                        i += 1
                    except WindowsError:
                        break
        except Exception as e:
            self.logger.error(f"Erreur lors de l'analyse du registre: {e}")
        
        return suspicious_entries

    def scan_scheduled_tasks(self):
        """
        Recherche les tâches planifiées liées à EduLocker (Windows uniquement).
        
        Returns:
            list: Liste des tâches planifiées suspectes
        """
        if not self.is_windows:
            return []
        
        self.logger.info("Analyse des tâches planifiées en cours...")
        suspicious_tasks = []
        
        try:
            # Utiliser schtasks pour lister toutes les tâches
            result = subprocess.run(
                ["schtasks", "/Query", "/FO", "CSV"], 
                capture_output=True, 
                text=True, 
                check=False
            )
            
            if result.returncode == 0:
                # Analyser la sortie CSV
                lines = result.stdout.splitlines()
                for line in lines[1:]:  # Ignorer l'en-tête
                    if not line.strip():
                        continue
                    
                    # Extraire le nom de la tâche (première colonne)
                    task_name = line.split(',')[0].strip('"')
                    
                    # Vérifier si le nom correspond à une signature connue
                    if any(sig.lower() in task_name.lower() for sig in self.scheduled_task_signatures):
                        suspicious_tasks.append({
                            'name': task_name
                        })
                        self.logger.info(f"Tâche planifiée suspecte trouvée: {task_name}")
        except Exception as e:
            self.logger.error(f"Erreur lors de l'analyse des tâches planifiées: {e}")
        
        return suspicious_tasks

    def scan_files(self):
        """
        Recherche les fichiers liés à EduLocker.
        
        Returns:
            list: Liste des fichiers suspects trouvés
        """
        self.logger.info("Analyse des fichiers en cours...")
        suspicious_files = []
        
        # Chemins à vérifier
        paths_to_check = [
            os.path.expanduser("~"),  # Dossier utilisateur
            os.path.join(os.path.expanduser("~"), "Downloads"),  # Téléchargements
            os.path.join(os.path.expanduser("~"), "Desktop"),  # Bureau
            os.path.join(os.path.expanduser("~"), "Documents"),  # Documents
        ]
        
        # Fichiers à rechercher
        file_signatures = ["EduLocker", "main.py", "locker.py", "persistence.py"]
        
        for path in paths_to_check:
            if not os.path.exists(path):
                continue
                
            for root, _, files in os.walk(path, topdown=True):
                for file in files:
                    # Limiter la profondeur de recherche pour éviter de scanner tout le disque
                    if root.count(os.sep) - path.count(os.sep) > 3:
                        continue
                        
                    if any(sig.lower() in file.lower() for sig in file_signatures):
                        file_path = os.path.join(root, file)
                        suspicious_files.append({
                            'path': file_path,
                            'name': file
                        })
                        self.logger.info(f"Fichier suspect trouvé: {file_path}")
        
        return suspicious_files


class EduLockerRemover:
    """Supprime le ransomware éducatif EduLocker du système."""

    def __init__(self, detection_results, logger=None):
        """
        Initialise le suppresseur EduLocker.
        
        Args:
            detection_results: Résultats de détection d'EduLocker
            logger: Logger pour enregistrer les actions (optionnel)
        """
        self.logger = logger or logging.getLogger('EduLockerRemover')
        self.detection_results = detection_results
        self.is_windows = platform.system() == "Windows"
        self.cleanup_results = {
            "processes_terminated": 0,
            "registry_entries_removed": 0,
            "scheduled_tasks_removed": 0,
            "files_quarantined": 0,
            "success": False
        }
        
        self.logger.info("Suppresseur EduLocker initialisé")

    def remove_malware(self):
        """
        Supprime toutes les instances d'EduLocker détectées.
        
        Returns:
            dict: Résultats du nettoyage
        """
        self.logger.info("Démarrage de la suppression d'EduLocker")
        
        # Terminer les processus
        self.terminate_processes()
        
        # Supprimer les entrées de registre
        if self.is_windows:
            self.remove_registry_entries()
            self.remove_scheduled_tasks()
        
        # Mettre en quarantaine les fichiers
        self.quarantine_files()
        
        # Restaurer les paramètres système
        self.restore_system_settings()
        
        # Déterminer si le nettoyage a réussi
        self.cleanup_results["success"] = (
            self.cleanup_results["processes_terminated"] == len(self.detection_results["processes"]) and
            self.cleanup_results["registry_entries_removed"] == len(self.detection_results["registry"]) and
            self.cleanup_results["scheduled_tasks_removed"] == len(self.detection_results["scheduled_tasks"])
        )
        
        self.logger.info(f"Suppression terminée. Succès: {self.cleanup_results['success']}")
        return self.cleanup_results

    def terminate_processes(self):
        """Termine les processus EduLocker détectés."""
        self.logger.info("Terminaison des processus EduLocker...")
        
        for proc in self.detection_results["processes"]:
            try:
                pid = proc['pid']
                process = psutil.Process(pid)
                process.terminate()
                
                # Attendre que le processus se termine
                try:
                    process.wait(timeout=3)
                except psutil.TimeoutExpired:
                    # Forcer la terminaison si le processus ne répond pas
                    process.kill()
                
                self.cleanup_results["processes_terminated"] += 1
                self.logger.info(f"Processus terminé: PID {pid}")
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                self.logger.error(f"Erreur lors de la terminaison du processus {proc['pid']}: {e}")
        
        return self.cleanup_results["processes_terminated"]

    def remove_registry_entries(self):
        """Supprime les entrées de registre EduLocker détectées (Windows uniquement)."""
        if not self.is_windows or not winreg:
            return 0
            
        self.logger.info("Suppression des entrées de registre EduLocker...")
        
        for entry in self.detection_results["registry"]:
            try:
                key_path = entry['location'].split('\\', 1)[1]  # Enlever "HKCU\"
                with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE) as key:
                    winreg.DeleteValue(key, entry['name'])
                
                self.cleanup_results["registry_entries_removed"] += 1
                self.logger.info(f"Entrée de registre supprimée: {entry['name']}")
            except Exception as e:
                self.logger.error(f"Erreur lors de la suppression de l'entrée de registre {entry['name']}: {e}")
        
        return self.cleanup_results["registry_entries_removed"]

    def remove_scheduled_tasks(self):
        """Supprime les tâches planifiées EduLocker détectées (Windows uniquement)."""
        if not self.is_windows:
            return 0
            
        self.logger.info("Suppression des tâches planifiées EduLocker...")
        
        for task in self.detection_results["scheduled_tasks"]:
            try:
                task_name = task['name']
                result = subprocess.run(
                    ["schtasks", "/Delete", "/TN", task_name, "/F"],
                    capture_output=True,
                    text=True,
                    check=False
                )
                
                if result.returncode == 0:
                    self.cleanup_results["scheduled_tasks_removed"] += 1
                    self.logger.info(f"Tâche planifiée supprimée: {task_name}")
                else:
                    self.logger.error(f"Erreur lors de la suppression de la tâche planifiée {task_name}: {result.stderr}")
            except Exception as e:
                self.logger.error(f"Erreur lors de la suppression de la tâche planifiée {task['name']}: {e}")
        
        return self.cleanup_results["scheduled_tasks_removed"]

    def quarantine_files(self):
        """Met en quarantaine les fichiers EduLocker détectés."""
        self.logger.info("Mise en quarantaine des fichiers EduLocker...")
        
        # Créer un dossier de quarantaine
        quarantine_dir = os.path.join(os.path.expanduser("~"), "EduLocker_Quarantine")
        try:
            if not os.path.exists(quarantine_dir):
                os.makedirs(quarantine_dir)
        except Exception as e:
            self.logger.error(f"Erreur lors de la création du dossier de quarantaine: {e}")
            return 0
        
        for file_info in self.detection_results["files"]:
            try:
                file_path = file_info['path']
                file_name = file_info['name']
                
                # Créer un nom unique pour éviter les collisions
                quarantine_name = f"{file_name}_{int(time.time())}"
                quarantine_path = os.path.join(quarantine_dir, quarantine_name)
                
                # Déplacer le fichier en quarantaine
                os.rename(file_path, quarantine_path)
                
                self.cleanup_results["files_quarantined"] += 1
                self.logger.info(f"Fichier mis en quarantaine: {file_path} -> {quarantine_path}")
            except Exception as e:
                self.logger.error(f"Erreur lors de la mise en quarantaine du fichier {file_info['path']}: {e}")
        
        return self.cleanup_results["files_quarantined"]

    def restore_system_settings(self):
        """Restaure les paramètres système modifiés par EduLocker."""
        self.logger.info("Restauration des paramètres système...")
        
        if self.is_windows:
            # Réactiver le Gestionnaire des tâches
            try:
                key_path = r"Software\Microsoft\Windows\CurrentVersion\Policies\System"
                with winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path) as key:
                    winreg.SetValueEx(key, "DisableTaskMgr", 0, winreg.REG_DWORD, 0)
                self.logger.info("Gestionnaire des tâches réactivé")
            except Exception as e:
                self.logger.error(f"Erreur lors de la réactivation du Gestionnaire des tâches: {e}")
            
            # Redémarrer explorer.exe s'il a été tué
            try:
                # Vérifier si explorer.exe est en cours d'exécution
                explorer_running = False
                for proc in psutil.process_iter(['name']):
                    if proc.info['name'] == 'explorer.exe':
                        explorer_running = True
                        break
                
                if not explorer_running:
                    subprocess.Popen("explorer.exe")
                    self.logger.info("Explorer.exe redémarré")
            except Exception as e:
                self.logger.error(f"Erreur lors du redémarrage d'explorer.exe: {e}")
        
        return True


class AntiMalwareGUI:
    """Interface graphique pour l'anti-malware EduLocker."""

    def __init__(self, root=None):
        """
        Initialise l'interface graphique de l'anti-malware.
        
        Args:
            root: Fenêtre racine Tkinter (optionnel)
        """
        # Configuration du logging
        self.logger = logging.getLogger('EduLocker.AntiMalware')
        
        # Initialiser la fenêtre principale
        self.root = root or tk.Tk()
        self.root.title("EduLocker Anti-Malware")
        self.root.geometry("700x500")
        self.root.resizable(True, True)
        
        # Variables
        self.scan_in_progress = False
        self.cleanup_in_progress = False
        self.detection_results = None
        
        # Créer l'interface
        self._create_widgets()
        
        self.logger.info("Interface anti-malware initialisée")

    def _create_widgets(self):
        """Crée les widgets de l'interface graphique."""
        # Frame principal
        main_frame = tk.Frame(self.root, padx=20, pady=20)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Titre
        title_label = tk.Label(
            main_frame,
            text="EduLocker Anti-Malware",
            font=("Arial", 18, "bold")
        )
        title_label.pack(pady=10)
        
        # Description
        description_label = tk.Label(
            main_frame,
            text="Cet outil détecte et supprime le ransomware éducatif EduLocker de votre système.",
            font=("Arial", 10),
            wraplength=600
        )
        description_label.pack(pady=10)
        
        # Frame pour les boutons
        button_frame = tk.Frame(main_frame)
        button_frame.pack(pady=20)
        
        # Bouton de scan
        self.scan_button = tk.Button(
            button_frame,
            text="Analyser le système",
            command=self._start_scan,
            width=20,
            height=2,
            bg="#4CAF50",
            fg="white",
            font=("Arial", 10, "bold")
        )
        self.scan_button.pack(side=tk.LEFT, padx=10)
        
        # Bouton de nettoyage
        self.cleanup_button = tk.Button(
            button_frame,
            text="Supprimer les menaces",
            command=self._start_cleanup,
            width=20,
            height=2,
            bg="#F44336",
            fg="white",
            font=("Arial", 10, "bold"),
            state=tk.DISABLED
        )
        self.cleanup_button.pack(side=tk.LEFT, padx=10)
        
        # Frame pour les résultats
        results_frame = tk.Frame(main_frame)
        results_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Label pour les résultats
        results_label = tk.Label(
            results_frame,
            text="Résultats de l'analyse:",
            font=("Arial", 12, "bold"),
            anchor="w"
        )
        results_label.pack(fill=tk.X)
        
        # Zone de texte pour les résultats
        self.results_text = tk.Text(
            results_frame,
            height=15,
            width=80,
            font=("Courier", 10),
            bg="#F0F0F0"
        )
        self.results_text.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar pour la zone de texte
        scrollbar = tk.Scrollbar(self.results_text)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.results_text.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=self.results_text.yview)
        
        # Barre de statut
        self.status_var = tk.StringVar()
        self.status_var.set("Prêt")
        status_bar = tk.Label(
            self.root,
            textvariable=self.status_var,
            bd=1,
            relief=tk.SUNKEN,
            anchor=tk.W
        )
        status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Barre de progression
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(
            self.root,
            variable=self.progress_var,
            maximum=100
        )
        self.progress_bar.pack(side=tk.BOTTOM, fill=tk.X, padx=20, pady=10)

    def _start_scan(self):
        """Démarre l'analyse du système."""
        if self.scan_in_progress:
            return
            
        self.scan_in_progress = True
        self.status_var.set("Analyse en cours...")
        self.scan_button.config(state=tk.DISABLED)
        self.cleanup_button.config(state=tk.DISABLED)
        self.results_text.delete(1.0, tk.END)
        self.progress_var.set(0)
        
        # Fonction pour exécuter l'analyse dans un thread
        def run_scan():
            try:
                self._update_progress(10)
                self._append_result("Démarrage de l'analyse du système...\n")
                
                # Créer le détecteur
                detector = EduLockerDetector(self.logger)
                
                # Analyser les processus
                self._update_progress(20)
                self._append_result("Analyse des processus en cours...\n")
                
                # Analyser le registre
                self._update_progress(40)
                self._append_result("Analyse du registre en cours...\n")
                
                # Analyser les tâches planifiées
                self._update_progress(60)
                self._append_result("Analyse des tâches planifiées en cours...\n")
                
                # Analyser les fichiers
                self._update_progress(80)
                self._append_result("Analyse des fichiers en cours...\n")
                
                # Effectuer l'analyse complète
                self.detection_results = detector.scan_system()
                
                # Afficher les résultats
                self._update_progress(100)
                self._display_scan_results()
                
                # Mettre à jour l'interface
                self.scan_in_progress = False
                self.scan_button.config(state=tk.NORMAL)
                
                # Activer le bouton de nettoyage si des menaces sont détectées
                if self.detection_results["detected"]:
                    self.cleanup_button.config(state=tk.NORMAL)
                
                self.status_var.set("Analyse terminée")
            except Exception as e:
                self.logger.error(f"Erreur lors de l'analyse: {e}")
                self._append_result(f"\nErreur lors de l'analyse: {e}\n")
                self.scan_in_progress = False
                self.scan_button.config(state=tk.NORMAL)
                self.status_var.set("Erreur lors de l'analyse")
        
        # Démarrer l'analyse dans un thread
        threading.Thread(target=run_scan, daemon=True).start()

    def _start_cleanup(self):
        """Démarre le nettoyage du système."""
        if self.cleanup_in_progress or not self.detection_results or not self.detection_results["detected"]:
            return
            
        # Demander confirmation
        if not messagebox.askyesno(
            "Confirmation",
            "Voulez-vous supprimer toutes les instances d'EduLocker détectées?\n\n"
            "Cette action va:\n"
            "- Terminer les processus EduLocker\n"
            "- Supprimer les entrées de registre\n"
            "- Supprimer les tâches planifiées\n"
            "- Mettre en quarantaine les fichiers suspects"
        ):
            return
            
        self.cleanup_in_progress = True
        self.status_var.set("Nettoyage en cours...")
        self.scan_button.config(state=tk.DISABLED)
        self.cleanup_button.config(state=tk.DISABLED)
        self.progress_var.set(0)
        
        # Fonction pour exécuter le nettoyage dans un thread
        def run_cleanup():
            try:
                self._update_progress(10)
                self._append_result("\n--- DÉBUT DU NETTOYAGE ---\n")
                
                # Créer le suppresseur
                remover = EduLockerRemover(self.detection_results, self.logger)
                
                # Terminer les processus
                self._update_progress(30)
                self._append_result("Terminaison des processus EduLocker...\n")
                
                # Supprimer les entrées de registre
                self._update_progress(50)
                self._append_result("Suppression des entrées de registre...\n")
                
                # Supprimer les tâches planifiées
                self._update_progress(70)
                self._append_result("Suppression des tâches planifiées...\n")
                
                # Mettre en quarantaine les fichiers
                self._update_progress(90)
                self._append_result("Mise en quarantaine des fichiers...\n")
                
                # Effectuer le nettoyage complet
                cleanup_results = remover.remove_malware()
                
                # Afficher les résultats
                self._update_progress(100)
                self._display_cleanup_results(cleanup_results)
                
                # Mettre à jour l'interface
                self.cleanup_in_progress = False
                self.scan_button.config(state=tk.NORMAL)
                self.cleanup_button.config(state=tk.DISABLED)
                
                self.status_var.set("Nettoyage terminé")
            except Exception as e:
                self.logger.error(f"Erreur lors du nettoyage: {e}")
                self._append_result(f"\nErreur lors du nettoyage: {e}\n")
                self.cleanup_in_progress = False
                self.scan_button.config(state=tk.NORMAL)
                self.status_var.set("Erreur lors du nettoyage")
        
        # Démarrer le nettoyage dans un thread
        threading.Thread(target=run_cleanup, daemon=True).start()

    def _display_scan_results(self):
        """Affiche les résultats de l'analyse."""
        results = self.detection_results
        
        self._append_result("\n--- RÉSULTATS DE L'ANALYSE ---\n")
        
        if results["detected"]:
            self._append_result("⚠️  EduLocker détecté sur le système!\n\n")
        else:
            self._append_result("✅ Aucune instance d'EduLocker n'a été détectée.\n\n")
        
        # Afficher les processus
        if results["processes"]:
            self._append_result(f"Processus suspects ({len(results['processes'])}):\n")
            for proc in results["processes"]:
                self._append_result(f"  - PID {proc['pid']}: {proc['cmdline']}\n")
            self._append_result("\n")
        
        # Afficher les entrées de registre
        if results["registry"]:
            self._append_result(f"Entrées de registre suspectes ({len(results['registry'])}):\n")
            for entry in results["registry"]:
                self._append_result(f"  - {entry['location']}\\{entry['name']}\n")
            self._append_result("\n")
        
        # Afficher les tâches planifiées
        if results["scheduled_tasks"]:
            self._append_result(f"Tâches planifiées suspectes ({len(results['scheduled_tasks'])}):\n")
            for task in results["scheduled_tasks"]:
                self._append_result(f"  - {task['name']}\n")
            self._append_result("\n")
        
        # Afficher les fichiers
        if results["files"]:
            self._append_result(f"Fichiers suspects ({len(results['files'])}):\n")
            for file in results["files"]:
                self._append_result(f"  - {file['path']}\n")
            self._append_result("\n")
        
        # Afficher le résumé
        self._append_result("--- RÉSUMÉ ---\n")
        total_threats = (
            len(results["processes"]) +
            len(results["registry"]) +
            len(results["scheduled_tasks"]) +
            len(results["files"])
        )
        self._append_result(f"Total des menaces détectées: {total_threats}\n")
        
        if results["detected"]:
            self._append_result("\nCliquez sur 'Supprimer les menaces' pour nettoyer le système.\n")

    def _display_cleanup_results(self, cleanup_results):
        """Affiche les résultats du nettoyage."""
        self._append_result("\n--- RÉSULTATS DU NETTOYAGE ---\n")
        
        if cleanup_results["success"]:
            self._append_result("✅ Nettoyage réussi! Toutes les menaces ont été supprimées.\n\n")
        else:
            self._append_result("⚠️  Nettoyage partiel. Certaines menaces n'ont pas pu être supprimées.\n\n")
        
        # Afficher le résumé
        self._append_result("Résumé des actions:\n")
        self._append_result(f"  - Processus terminés: {cleanup_results['processes_terminated']}\n")
        self._append_result(f"  - Entrées de registre supprimées: {cleanup_results['registry_entries_removed']}\n")
        self._append_result(f"  - Tâches planifiées supprimées: {cleanup_results['scheduled_tasks_removed']}\n")
        self._append_result(f"  - Fichiers mis en quarantaine: {cleanup_results['files_quarantined']}\n")
        
        self._append_result("\nLe système est maintenant protégé contre EduLocker.\n")

    def _update_progress(self, value):
        """Met à jour la barre de progression."""
        self.progress_var.set(value)
        self.root.update_idletasks()

    def _append_result(self, text):
        """Ajoute du texte à la zone de résultats."""
        self.results_text.insert(tk.END, text)
        self.results_text.see(tk.END)
        self.root.update_idletasks()

    def run(self):
        """Démarre l'interface graphique."""
        self.root.mainloop()


def setup_logging():
    """Configure le système de logging pour l'anti-malware."""
    log_dir = "logs"
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    log_filename = f"logs/edulocker_antimalware_{time.strftime('%Y%m%d_%H%M%S')}.log"

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_filename),
            logging.StreamHandler(sys.stdout)
        ]
    )

    return logging.getLogger('EduLocker.AntiMalware')


def run_gui():
    """Fonction principale pour exécuter l'interface graphique anti-malware."""
    logger = setup_logging()
    logger.info("Démarrage de l'anti-malware EduLocker")
    
    try:
        root = tk.Tk()
        app = AntiMalwareGUI(root)
        app.run()
    except Exception as e:
        logger.error(f"Erreur lors de l'exécution de l'interface graphique: {e}")
        messagebox.showerror(
            "Erreur",
            f"Une erreur est survenue lors de l'exécution de l'anti-malware:\n{e}"
        )


def run_cli_scan():
    """Fonction pour exécuter une analyse en ligne de commande."""
    logger = setup_logging()
    logger.info("Démarrage de l'analyse en ligne de commande")
    
    try:
        print("=== EduLocker Anti-Malware ===")
        print("Analyse du système en cours...")
        
        detector = EduLockerDetector(logger)
        results = detector.scan_system()
        
        print("\n=== Résultats de l'analyse ===")
        
        if results["detected"]:
            print("⚠️  EduLocker détecté sur le système!")
        else:
            print("✅ Aucune instance d'EduLocker n'a été détectée.")
        
        # Afficher les détails
        total_threats = (
            len(results["processes"]) +
            len(results["registry"]) +
            len(results["scheduled_tasks"]) +
            len(results["files"])
        )
        
        print(f"\nTotal des menaces détectées: {total_threats}")
        
        if results["processes"]:
            print(f"\nProcessus suspects ({len(results['processes'])}):")
            for proc in results["processes"]:
                print(f"  - PID {proc['pid']}: {proc['cmdline']}")
        
        if results["registry"]:
            print(f"\nEntrées de registre suspectes ({len(results['registry'])}):")
            for entry in results["registry"]:
                print(f"  - {entry['location']}\\{entry['name']}")
        
        if results["scheduled_tasks"]:
            print(f"\nTâches planifiées suspectes ({len(results['scheduled_tasks'])}):")
            for task in results["scheduled_tasks"]:
                print(f"  - {task['name']}")
        
        if results["files"]:
            print(f"\nFichiers suspects ({len(results['files'])}):")
            for file in results["files"]:
                print(f"  - {file['path']}")
        
        # Demander si l'utilisateur veut nettoyer le système
        if results["detected"]:
            response = input("\nVoulez-vous supprimer toutes les instances d'EduLocker détectées? (o/N): ")
            
            if response.lower() == 'o':
                print("\nNettoyage du système en cours...")
                
                remover = EduLockerRemover(results, logger)
                cleanup_results = remover.remove_malware()
                
                print("\n=== Résultats du nettoyage ===")
                
                if cleanup_results["success"]:
                    print("✅ Nettoyage réussi! Toutes les menaces ont été supprimées.")
                else:
                    print("⚠️  Nettoyage partiel. Certaines menaces n'ont pas pu être supprimées.")
                
                print("\nRésumé des actions:")
                print(f"  - Processus terminés: {cleanup_results['processes_terminated']}")
                print(f"  - Entrées de registre supprimées: {cleanup_results['registry_entries_removed']}")
                print(f"  - Tâches planifiées supprimées: {cleanup_results['scheduled_tasks_removed']}")
                print(f"  - Fichiers mis en quarantaine: {cleanup_results['files_quarantined']}")
                
                print("\nLe système est maintenant protégé contre EduLocker.")
        
        return results
    except Exception as e:
        logger.error(f"Erreur lors de l'analyse en ligne de commande: {e}")
        print(f"Erreur: {e}")
        return None


if __name__ == "__main__":
    # Exécuter l'interface graphique par défaut
    run_gui()